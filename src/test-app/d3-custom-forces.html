<!DOCTYPE html>
<meta charset="utf-8">
<style>
.node circle {
  stroke: black	;
  stroke-width: 0px;
}
.path{
    fill: none;
    stroke: #666;
    stroke-width: 1.5px;
}

svg {  }
</style>
<svg width="900" height="900"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
//create somewhere to put the force directed graph
const svg = d3.select("svg"),
    width  = + svg.attr("width"),
    height = + svg.attr("height");

const radius = 5,
    center = { "x": width / 2, "y": height / 2 },
    axis = Math.min(width, height) * 0.45;

const margins = {
    "A": axis,
    "B": axis * 0.7,
    "C": axis * 0.7,
    "D": axis * 0.9
};

const graph = {
    nodes : [
        {   "id"  : "node_u", "name": "u", "val" : 10, "color": "#D2691E", "graph": "A", "type": "+"},
        {   "id"  : "node_n", "name": "n", "val" : 10, "color": "#D2691E", "graph": "A", "type": "-"},
        {   "id"  : "node_t", "name": "t", "val" : 10, "color": "#808080", "graph": "B", "type": "-"},
        {   "id"  : "node_a", "name": "a", "val" : 10, "color": "#808080", "graph": "B", "type": "0"},
        {   "id"  : "node_h", "name": "h", "val" : 10, "color": "#444444", "graph": "B", "type": "+"},
        {   "id"  : "node_R", "name": "R", "val" : 10, "color": "#ff0000", "graph": "C", "type": "-" },
        {   "id"  : "node_L", "name": "L", "val" : 10, "color": "#7B68EE", "graph": "C", "type": "+"},
        {   "id"  : "node_S", "name": "\u03A3", "val" : 10, "color": "#006400", "graph": "D", "type": "-"},
        {   "id"  : "node_P", "name": "\u03C0", "val" : 10, "color": "#0000CD", "graph": "D", "type": "+"}
    ],
    links : [
        {   "source": "node_u", "target": "node_n", "name": "",          "type": "link", "length": 100},
        {   "source": "node_t", "target": "node_a", "name": "Ependymal", "type": "link", "length": 35 },
        {   "source": "node_a", "target": "node_h", "name": "Ependymal", "type": "link", "length": 35 },
        {   "source": "node_R", "target": "node_L", "name": "Pulmonary", "type": "path", "length": 70 },
        {   "source": "node_L", "target": "node_R", "name": "Systemic",  "type": "path", "length": 70 },
        {   "source": "node_S", "target": "node_P", "name": "Gut",       "type": "path", "length": 90 },
        {   "source": "node_P", "target": "node_S", "name": "Gut'",      "type": "path", "length": 90 },
        //invisible force links
        {   "source": "node_t", "target": "node_n", "name": "",          "type": "force", "length": 15},
        {   "source": "node_h", "target": "node_u", "name": "",          "type": "force", "length": 15},
        {   "source": "node_S", "target": "node_n", "name": "",          "type": "force", "length": 5 },
        {   "source": "node_P", "target": "node_u", "name": "",          "type": "force", "length": 5 },
        ]
};

// Bring all '-' nodes to the left side, all '+' nodes to right side
function splitting_force() {
  for (var i = 0, n = graph.nodes.length; i < n; ++i) {
    curr_node = graph.nodes[i];
    if(curr_node.type == "-"){
        if (curr_node.graph === "C"){
            curr_node.y += 5;
        } else {
            curr_node.x += 5;
        }
    } else
        if(curr_node.type == "+"){
            if (curr_node.graph === "C"){
                curr_node.y -= 5;
            } else {
                curr_node.x -= 5;
            }
    }    
  }
}

//set up the simulation
var simulation = d3.forceSimulation().nodes(graph.nodes);

simulation
    .force("link", d3.forceLink(graph.links).id(function(d) { return d.id }))
    .force("link", d3.forceLink(graph.links)
        .distance(function(d) {//Stretch graphs by creating overall length deficit
            return 0.01 * d.length * (2 * axis) * ((d.source.graph === "A")? 1: 0.7);
        }).strength(0.9))
    .force("collide",d3.forceCollide( function(d){return d.r}).iterations(16))
    .force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter(center.x, center.y))
    .force("y", d3.forceY(0))
    .force("x", d3.forceX(0))
    //.force("splitting",splitting_force)
;

//simulation.force("link", d3.forceLink(graph.links)
//    .distance(function(d) {//Stretch graphs by creating overall length deficit
//        return 0.01 * d.length * (2 * axis) * ((d.source.graph === "A")? 1: 0.7);
//    }).strength(0.9));

simulation.on("tick", tick );

var path = svg.append("g").selectAll("path")
    .data(graph.links)
    .enter().append("path")
    .attr("id", function(d,i) { return "path_" + i; }) //a unique ID to reference later
    .attr("class", "path");

var pathLabel = svg.append("g").selectAll("path")
    .data(graph.links).enter().append("text")
    .attr("class", "pathLabel")
    .style("text-anchor","middle")
    .append("textPath")
    .attr("xlink:href",function(d,i){return "#path_" + i;}) //path ID
    .attr("startOffset", "50%")
    .text(function(d) { return d.name; }); //place the text halfway on the arc

var node = svg.append("g").attr("class", "node").selectAll("circle")
    .data(graph.nodes).enter()
    .append("circle")
    .attr("r", radius)
    .attr("fill", function(x){return x.color});

var nodeLabel = svg.append("g").selectAll("node").data(graph.nodes)
    .enter().append("text")
    .attr("class", "nodeLabel")
    .attr("x", 1.2 * radius)
    .attr("y", 1.2 * radius)
    .text(function(d) { return d.name; });

var drag_handler = d3.drag()
    .on("start", drag_start)
    .on("drag", drag_drag)
    .on("end", drag_end);

drag_handler(node);

//drag handler
function drag_start(d) {
    if (!d3.event.active) { simulation.alphaTarget(0.8).restart(); }
    d.fx = d.x;
    d.fy = d.y;
}
function drag_drag(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
}
function drag_end(d) {
    if (!d3.event.active) { simulation.alphaTarget(0); }
    d.fx = null;
    d.fy = null;
}


function drawEdge(d) {
    if (d.type === "path"){
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy) / 4;
        return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
    } else {
        if (d.type === "link"){
            return "M" + d.source.x + "," + d.source.y + " L " + d.target.x + "," + d.target.y;
        }
    }
}

function transform(d) {
    return "translate(" + d.x + "," + d.y + ")";
}

//const foci = [{x: 0, y: center.y}, {x: width, y: center.y}, {x: center.x, y: 0}, {x: center.x, y: height}];

function tick() {
//    // Push nodes toward their designated focus.
//    var k = .1 * d.alpha;
//    graph.nodes.forEach(function(o, i) {
//        o.y += (foci[o.id].y - o.y) * k;
//        o.x += (foci[o.id].x - o.x) * k;
//    });

    node
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });


    node
        .attr("cx", function(d) { return d.x = Math.max(center.x - margins[d.graph] + radius,
            Math.min(center.x + margins[d.graph] - radius, d.x));})
        .attr("cy", function(d) { return d.y = Math.max(center.y - margins[d.graph] + radius,
            Math.min(center.y + margins[d.graph] - radius, d.y)); });

    nodeLabel.attr("transform", transform);
    path.attr("d", drawEdge);

}
</script>